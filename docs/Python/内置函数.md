## map()

返回一个将 `function` 应用于 `iterable` 的每一项，并产生其结果的迭代器。 如果传入了额外的 `iterables` 参数，则 `function` 必须接受相同个数的参数并被用于到从所有可迭代对象中并行获取的项。当有多个可迭代对象时，当最短的可迭代对象耗尽则整个迭代将会停止。

```python
map(function, iterable, *iterables)
```

```python
def square(x):
    return x ** 2

result1 = map(square, [1, 2, 3])
print(result1, list(result1))

result2 = map(lambda x: x ** 2, [2, 3, 4])
print(result2, list(result2))

result3 = map(lambda x, y: x >= y, [2, 3, 4], [2, 4, 4, 5])
print(result3, list(result3))

>>>
<map object at 0x00000190BEF4AE60> [1, 4, 9]
<map object at 0x00000190BEF4AE30> [4, 9, 16]
<map object at 0x00000202CA95ACE0> [True, False, True]
```

## filter()

`filter()` 函数用于过滤序列，过滤掉不符合条件的元素，返回一个迭代器对象。

将 `iterable` 中的每个元素作为参数列表传递给 `function` 进行判断，最后将返回 `True` 的元素构建为一个迭代器。`iterable` 可以是一个序列，一个支持迭代的容器或者一个迭代器。如果 `function` 为 `None`，则会使用标识号函数，也就是说 `iterable` 中所有具有 `False` 值的元素都会被移除。

```python
filter(function, iterable)
```

>   **注意：**`filter(function, iterable)`相当于一个生成器表达式，当`function`不是`None`时为`(item for item in iterable if function(item))`；`function`是`None`时为`(item for item in iterable if item)`。

```python
age = [18, 19, 20, 21]
result = filter(lambda data: data <= 20, age)
print(list(result))

>>>
[18, 19, 20]
```

## zip() 函数

`zip()` 函数用于将一个或多个可迭代对象压缩成一个 `zip` 对象，压缩指的是将这些对象中对应位置的元素重新组合打包成一个个元组，然后返回由这些元组组成的对象，这样做的好处是节约了不少的内存。

可以使用 `list()` 转换来输出列表。

如果各个可迭代对象的元素个数不一致，则返回列表长度与最短的对象相同，利用 `*` 号操作符，可以将元组解压为列表。

```python
zip(iterable, ...)
```

-   `iterable`: 指一个或多个可迭代对象

```python
# 基本使用

list1 = [1, 2, 3]
list2 = ['a', 'b', 'c']
zipped = zip(list1, list2)
for item in zipped:
    print(type(item), item)

>>>
<class 'tuple'> (1, 'a')
<class 'tuple'> (2, 'b')
<class 'tuple'> (3, 'c')
```

```python
# 转换为列表

list1 = [1, 2, 3]
list2 = ['a', 'b', 'c']
zipped = list(zip(list1, list2))
print(type(zipped), zipped)

>>>
<class 'list'> [(1, 'a'), (2, 'b'), (3, 'c')]
```

```python
list1 = [1, 2]
list2 = ['a', 'b', 'c']
zipped = zip(list1, list2)
for item in zipped:
    print(type(item), item)
    
>>>
<class 'tuple'> (1, 'a')
<class 'tuple'> (2, 'b')
```

## round() 函数

返回 `number` 舍入到小数点后 `ndigits` 位精度的值。 如果 `ndigits` 被省略或为 `None`，则返回最接近输入值的整数。

```python
round(number, [ndigits=None])
```

对于支持 [`round()`](https://docs.python.org/zh-cn/3/library/functions.html#round) 方法的内置类型，结果值会舍入至最接近的 10 的负 `ndigits` 次幂的倍数；如果与两个倍数同样接近，则选用偶数。因此，`round(0.5)` 和 `round(-0.5)` 均得出 `0` 而 `round(1.5)` 则为 `2`。`ndigits` 可为任意整数值（正数、零或负数）。如果省略了 `ndigits` 或为 `None` ，则返回值将为整数。否则返回值与 `number` 的类型相同。

对于一般的 Python 对象 `number`, `round` 将委托给 `number.__round__`。

>   对浮点数执行 [`round()`](https://docs.python.org/zh-cn/3/library/functions.html#round) 的行为可能会令人惊讶：例如，`round(2.675, 2)` 将给出 `2.67` 而不是期望的 `2.68`。 这不算是程序错误：这一结果是由于大多数十进制小数实际上都不能以浮点数精确地表示。 请参阅 [浮点算术：争议和限制](https://docs.python.org/zh-cn/3/tutorial/floatingpoint.html#tut-fp-issues) 了解更多信息。

```python
print(round(1.12345, 4))

>>>
1.1235
```



## reversed() 函数

`reserved()` 函数其功能是对于给定的序列（包括列表、元组、字符串以及 `range(n)` 区间），该函数可以返回一个逆序序列的迭代器（用于遍历该逆序序列）。

```python
reserved(seq)
```

-   `seq`： 要转换的序列，可以是 `tuple`, `string`, `list` 或 `range`

```python
name = 'zhums'
print(list(reversed(name)))
print(name)

>>>
['s', 'm', 'u', 'h', 'z']
zhums
```

## sorted() 函数

`sorted()` 函数用于对所有可迭代的对象进行排序操作。

>   **`sort` 与 `sorted` 区别：**
>
>   1.  `sort` 是应用在 `list` 上的方法，`sorted` 可以对所有可迭代的对象进行排序操作。
>   2.  `sort` 方法返回的是对已经存在的列表进行操作，而 `sorted` 函数返回的是一个新的 `list`。

```python
sorted(iterable, key=None, reverse=False)  
```

-   `iterable`: 可迭代对象
-   `key`: 自定义排序规则
-   `reverse`: 排序规则，默认 `False` 升序，`True` 降序

**1、基本用法**

```python
list1 = [5,3,4,2,1]
tup1 = (5,4,3,1,2)
dict1 = {4:1, 5:2, 3:3, 2:6, 1:8}
set1 = {1,5,3,2,4}
str1 = "51423"
print(sorted(list1))			# 对列表进行排序
print(sorted(tup1))				# 对元组进行排序
print(sorted(dict1.items()))	# 字典默认按照 key 进行排序
print(sorted(set1))				# 对集合进行排序
print(sorted(str1))				# 对字符串进行排序

>>>
[1, 2, 3, 4, 5]
[1, 2, 3, 4, 5]
[(1, 8), (2, 6), (3, 3), (4, 1), (5, 2)]
[1, 2, 3, 4, 5]
['1', '2', '3', '4', '5']
```

**2、降序排序**

```python
str1 = "51423"
print(sorted(str1))
print(sorted(str1, reverse=True))

>>>
['1', '2', '3', '4', '5']
['5', '4', '3', '2', '1']
```

**3、自定义排序**

```python
name = ['zhums', 'wuyi', 'zhaoshiyu']
print(sorted(name))
print(sorted(name, key=len))		# 按照字符串长度排序

>>>
['wuyi', 'zhaoshiyu', 'zhums']
['wuyi', 'zhums', 'zhaoshiyu']
```

```python
tup1 = [("Alice", 85), ("Bob", 72), ("Eve", 95)]
print(sorted(tup1, key=lambda a: a[1]))		# 根据元组中的第二个元素进行排序

>>>
[('Bob', 72), ('Alice', 85), ('Eve', 95)]
```

## eval()函数

`eval()` 函数的语法格式如下：

```python
eval(expression[, globals=None[, locals=None]])
```

-   `expression`：指定要执行的语句，必须是字符串。
-   `globals`：这个参数管控的是一个全局的命名空间，即 expression 可以使用全局命名空间中的函数。如果只是提供了 globals 参数，而没有提供自定义的 __builtins__，则系统会将当前环境中的 __builtins__ 复制到自己提供的 globals 中，然后才会进行计算；如果连 globals 这个参数都没有被提供，则使用 Python 的全局命名空间。
-   `locals`：这个参数管控的是一个局部的命名空间，和 globals 类似，当它和 globals 中有重复或冲突时，以 locals 的为准。如果 locals 没有被提供，则默认为 globals。

## exec()函数

`exec()` 函数的语法格式如下：

```python
exec(expression[, globals=None[, locals=None]])
```

# 